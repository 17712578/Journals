08/03/2017
The drivers have a speed range of 20,000 to -20000.
Normally 7 variables are linked to one platform

Problems
	PE034 is not built in to the system
	Header file cannot be found
	Reflective memory is not connected to the embedded server 


09/03/2017
The driver manaul
-The driver contains API functions that enable you to
	Open and close the driver
	Configure the board
	Transfer data 
	Control/handle interrupts events
- When writing code
	The first step is to open the driver
	You can call RFM2gErrorMsg() function with the error to retrieve a description of the error code
	Byte swapping may be required due to different systems requiring Big Endian & Little Endian 


10/03/2017
-To convert a decimal from a variable back in ascii
	Decimal => hexdecimal => break into two individual bytes => compare against ascii table
- My first Task is
	To write some code that will load a pallet on to platform 21 and then have the platform move the
	pallet 23 & 24, which centres the pallet over the coilcar lifter.  
	Functions required are RFM2gPoke32, STDRFM2GCALL and a delay loop as we are unable to read the LEDs yet

13/03/2017
-First task is all most complete, just need to adjust timing as the Leds are not impleted as variables yet



code as at 13/03

		// STDRFM2GCALL result = RFM2gPoke32(handle, Offset+Index*4,Value) Offset = 0x708840;
		{	
		STDRFM2GCALL result = RFM2gPoke32(handle, 7378564,33554432) // Booking_Pallet_ID 
		STDRFM2GCALL result = RFM2gPoke32(handle, 7376450,1345388544) // Poke "P1" into Booking_Pallet_ID_1 
		
		STDRFM2GCALL result = RFM2gPoke32(handle, 7376496,83886080) // Booking_Pallet_Location 
		STDRFM2GCALL result = RFM2gPoke32(handle, 7376500,1346711602) //Poke "PE02" into Booking_Pallet_Location
		STDRFM2GCALL result = RFM2gPoke32(handle, 7376504,822083584) // Poke "1" Booking_Pallet_Location
		
		STDRFM2GCALL result = RFM2gPoke32(handle, 7376516,1) //Set Booking_Pallet_BookIn to "True" by inserting a '1'
		sw_delay_ms(500);										 //Delay
		STDRFM2GCALL result = RFM2gPoke32(handle, 7376516,0) //Set it back to "false"
		sw_delay(500);	
		
		STDRFM2GCALL result = RFM2gPoke32(handle, 7376648,-5000) //Speed
		STDRFM2GCALL result = RFM2gPoke32(handle, 7376780,1) //Drive on


14/03/2017
The swap function we are trying to update
 int main (void)
{
	char Name[20];
	char NewName[20];
	unsigned int num1 = 0;
	unsigned int num2 = 0;
	unsigned int num3 = 0;
	unsigned int num4 = 0;
	
	//while ((fgets( Name, sizeof(Name), stdin ) == (char *) NULL ) ||(strlen(Name) < 2))
    	sprintf(Name, "PE021");
   	 printf("The length of Name is: %d, NewName: %s\n",strlen(Name),  NewName);
//	int a = 0;
	for (int i = 5-1; i >= 0; i--)	
	{
		NewName[5-i] = Name[i];
	//	a++;
	}
	printf("Name: %s, NewName: %s, the length of it is. %d \n",Name,  NewName, strlen(NewName));
	
	for (int i = (strlen(NewName) - 1); i >= 0; i--)	
	{
	   if (strlen(NewName) - i <= 4)
	    { 
	    	num1 = (num1 << 8) + NewName[i];
    	}
        else if(strlen(NewName)- i <= 8)
    	{ 
	    	num2 = (num2 << 8) + NewName[i];
    	}
    	else if(strlen(NewName)- i <= 12)
    	{ 
	    	num3 = (num3 << 8) + NewName[i];
    	}
    	else if(strlen(NewName)- i <= 16)
    	{ 
	    	num4 = (num4 << 8) + NewName[i];
    	}
    	
	}
    printf("%d,%d,%d,%d\n",num1,num2,num3,num4);
}



14/03/2017
Add swap function and add a description
void Swapstring (void)
{
	char Name[20];
	unsigned int num1 = 0;
	unsigned int num2 = 0;
	unsigned int num3 = 0;
	unsigned int num4 = 0;
    	int i;
	
	while ((fgets( Name, sizeof(Name), stdin ) == (char *) NULL ) ||(strlen(Name) < 2)){} // This is where the code asks for user input
    
	if (Name[strlen(Name) - 1] == '\n') 	// In C89 the arrays always have a new line character at the end of the array, this was causing problems when converting to an int
   	 Name[strlen(Name) - 1] = '\0';		// So these two lines of code removed the '\n' and replace it with null character '\o'
    
    	int a = 0;

	for (i = (strlen(Name) - 1); i >= 0; i--)	// This for loop swaps the character order in the array and groups them into fours 
	{
	   if (strlen(Name) - a >= 13)
	    { 
	    	num4 = (num4 << 8) + Name[i];
	    	a++;
    	    }
       	    else if(strlen(Name)- a >= 9)
    	    { 
	    	num3 = (num3 << 8) + Name[i];
	     	a++;
    	    }
    	    else if(strlen(Name)- a >= 5)
    	    { 
	    	num2 = (num2 << 8) + Name[i];		// "<< 8" is beasuse we need to shift the numbers in hex 
	    	a++;
            }
    	    else if(strlen(Name)- a >= 0)		// Eg. 'P''E''0''2''1' => '1''2''0''E''P'=> 0x31,0x32,0x30,0x45,0x50 => num1 = 0x32,0x30,0x45,0x50. num2 = 0x31
    	    { 
	    	num1 = (num1 << 8) + Name[i];		//i think this for loop is best code i have ever written
	    	a++;
    	    }
	}
    
	if(direction == 1)
	{
		result = RFM2gPoke32(Handle, offset + Booking_Pallet_ID_1*4,num1); 	//  Poke the Name of Pallet into variable Booking_Pallet_ID_1 
		result = RFM2gPoke32(Handle, offset + Booking_Pallet_ID_2*4,num2); 	//  Poke the Name of Pallet into variable Booking_Pallet_ID_2
		result = RFM2gPoke32(Handle, offset + Booking_Pallet_ID_3*4,num3); 	//  Poke the Name of Pallet into variable Booking_Pallet_ID_3 
		result = RFM2gPoke32(Handle, offset + Booking_Pallet_ID_4*4,num4); 	//  Poke the Name of Pallet into variable Booking_Pallet_ID_3
	}
	if(direction == 2)
	{
		result = RFM2gPoke32(Handle, offset + Booking_Pallet_Location_1*4,num1); 	//  Poke the Name of Pallet into variable Booking_Pallet_ID_1 
		result = RFM2gPoke32(Handle, offset + Booking_Pallet_Location_2*4,num2); 	//  Poke the Name of Pallet into variable Booking_Pallet_ID_2
		result = RFM2gPoke32(Handle, offset + Booking_Pallet_Location_3*4,num3); 	//  Poke the Name of Pallet into variable Booking_Pallet_ID_3 
		result = RFM2gPoke32(Handle, offset + Booking_Pallet_Location_4*4,num4); 	//  Poke the Name of Pallet into variable Booking_Pallet_ID_3
	}
}	



15/03/2017
		
	void main()
{
		 result = RFM2gPoke32(Handle, offset + Booking_Pallet_ID*4,Pallet_ID); 			// Constant
		 SetPalletName(); 									// Asks user for name of Pallet, swapString is called from this function 
		 result = RFM2gPoke32(Handle, offset + Booking_Pallet_Location*4,Pallet_Location);	// Constant
		 SetLocationofPallet();									// Asks user for Location of Pallet, swapString is called from this function 
		 result = RFM2gPoke32(Handle, offset + Booking_Pallet_BookIn*4,True); 			//Book in that pallet to the location
		 sleep(1);										//Delay for a second
		 result = RFM2gPoke32(Handle, offset + Booking_Pallet_BookIn*4,False); 			//Then reset the bookin variable so it can be used again another time
		 result = RFM2gPoke32(Handle, offset + DPSIM__ScaledRotSpd_PE021*4,Speed); 		//Set speed of motors to a hardcoded value, will fix this later
		 result = RFM2gPoke32(Handle, offset + DPSIM__DriveOn_PE021*4,1); 			//Turn on the platform
		 result = RFM2gPoke32(Handle, offset + DPSIM__ScaledRotSpd_PE24*4,Speed);		//"			"
		 result = RFM2gPoke32(Handle, offset + DPSIM__DriveOn_PE024*4,1); 			//"			"
		 sleep(68);										//Wait for the pallet to be transfer across the platfroms
		 result = RFM2gPoke32(Handle, offset + DPSIM__DriveOn_PE021*4,0); 			//Turn Platforms off
		 result = RFM2gPoke32(Handle, offset + DPSIM__DriveOn_PE024*4,0); 			//	 
}


21/03/2017

	void main()
{
		//result = RFM2gPoke32(handle, Offset+Index*4,Value) Offset = 0x708840;	
		 result = RFM2gPoke32(Handle, offset + Booking_Pallet_ID*4,Starting_ID);	 	// Constant
		 result = RFM2gPoke32(Handle, offset + Booking_Coil_ID*4,Starting_ID); 			// Constant
		 SetPalletName(); 									// Calls the Function which receives the name of the pallet from the User
		 
		 result = RFM2gPoke32(Handle, offset + Booking_Pallet_Location*4,Starting_Location);	// Constant
		 result = RFM2gPoke32(Handle, offset + Booking_Coil_Location*4,Starting_Location);	// Constant
		 SetLocationofPallet(); 								// Calls the Function which receives the required location from the user
		 
		 /* Set parameters of the aluminium coil */

		 result = RFM2gPoke32(Handle, offset + Booking_Coil_OuterDiameter*4,OuterDiameter);		
		 result = RFM2gPoke32(Handle, offset + Booking_Coil_InnerDiameter*4,InnerDiameter);
		 result = RFM2gPoke32(Handle, offset + Booking_Coil_Width*4,Width);
		 result = RFM2gPoke32(Handle, offset + Booking_Coil_Thickness*4,Thickness);
		 result = RFM2gPoke32(Handle, offset + Booking_Coil_Temperature*4,Temperature);
		 
		 /* Books in the Pallet and Coil, also reset the variables back to off so it is possible to use again*/

		 result = RFM2gPoke32(Handle, offset + Booking_Pallet_BookIn*4,On); 	
		 result = RFM2gPoke32(Handle, offset + Booking_Pallet_BookIn*4,Off); 		
		 sleep(1);										//Give the pallet time to appear on screen
		 result = RFM2gPoke32(Handle, offset + Booking_Coil_BookIn*4,On); 	
		 result = RFM2gPoke32(Handle, offset + Booking_Coil_BookIn*4,Off); 		
		
		 /* Turn on and adjust speed of platforms*/

		 result = RFM2gPoke32(Handle, offset + ScaledRotSpd_PE021*4,Speed); 
		 result = RFM2gPoke32(Handle, offset + DriveOn_PE021*4,1); 
		 result = RFM2gPoke32(Handle, offset + ScaledRotSpd_PE024*4,Speed); 
		 result = RFM2gPoke32(Handle, offset + DriveOn_PE024*4,1); 
		 sleep(67); 										//Wait for pallet to arrive at position
		 result = RFM2gPoke32(Handle, offset + DriveOn_PE021*4,0); 				//Turn off platforms
		 result = RFM2gPoke32(Handle, offset + DriveOn_PE024*4,0); 
		 
		 /* Turn on and adjust speed of the Coil Car*/

		 result = RFM2gPoke32(Handle, offset + Tr1OpenBreak_CC*4,On); 				//Sart
		result = RFM2gPoke32(Handle, offset + Tr1ScaledRotSpd_CC*4,PositiveSpeed); 
		sleep(23);										//Wait for Coilcar to arrive at position												
		result = RFM2gPoke32(Handle, offset + Tr1ScaledRotSpd_CC*4,Off); 			//Stop
		result = RFM2gPoke32(Handle, offset + Tr1CoilLifterSvoVlv*4,4234310);			//Raise lifter
		sleep(5);										//Wait for lifter to reach desired height
        
		 /* Read the actual position of the Coil Car, convert this real data to
			an integer and compare to the end position */

		 result = RFM2gPeek32(Handle, offset + CcarTR1_ActPos*4,&BitpatternPos);
		 SwapBitPattern = htole32(BitpatternPos);
		 memcpy(&ActPos, &SwapBitPattern, sizeof(RFM2G_UINT32));
		 while (ActPos <= End_Position)
		 {
			 result = RFM2gPoke32(Handle, offset + Tr1ScaledRotSpd_CC*4,PositiveSpeed);	// Stays trapped within this while loop until the Car reaches its desination 
			 result = RFM2gPeek32(Handle, offset + CcarTR1_ActPos*4,&BitpatternPos);
			 SwapBitPattern = htole32(BitpatternPos);
			 memcpy(&ActPos, &SwapBitPattern, sizeof(RFM2G_UINT32));
		 }
		 result = RFM2gPoke32(Handle, offset + Tr1ScaledRotSpd_CC*4,False);			//Turn off Coilcar
}


31/03/2017
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
The Layout of the directory inside the Eclipse workspace, only important files shown. 

part.component.connentor.c
     >>	testsuite
     	     >>	drivebelt			(Java package, run as java application to start program)
		     >>	TestCDrivebelt		(Simple java file that creates input & output ports)
			TestConnectorDrivebelt	(A more complex java file shown below)
     >>	src.c.testsuite
	     >>	driveBeltsimple.simple
		     >>	Local.h 	(Header file that contains all the factory variables)
			main.c 		(Main C file)
			main.o		(Executeable file for main.c)
			makefile 	(Makefile which links the directory of all other header files)
			libdriveBeltsimple.sc



/* TestConnectorDrivebelt */

package drivebelt;

import part.connector.c.task.SingleTimedCTask;
import director.timedirector.simpleapi.TimeTriggeredDomain;
import scenario.consolescenario.ConsoleScenario;
import simulator.core.framework.api.ScenarioIF;
import simulator.core.framework.components.link.LinkImpl;
import simulator.core.framework.director.coredirector.Director;
import simulator.core.framework.time.SimulationDuration;
import simulator.core.framework.time.SimulationTime;
import sumController.helper.ConstantValueProvider;
import testsuite.connector.c.timed.simpletask.behavior.TTValueConsumer;

/**
 * Test class for the simulator
 * 
 * This test scenario consists of a time triggered director that has a nested event
 * triggered director
 * 
 * @author Dr. Thomas Kuhn
 *
 */

public class TestConnectorDrivebelt 
{

    /**
     * Store simulation scenario
     */
    
    protected ScenarioIF simulationScenario;
    
    
    /**
     * Constructor
     * Sets up simulation scenario
     */

    public TestConnectorDrivebelt() 
    {
	// Create scenario with defined ending time
        simulationScenario = new ConsoleScenario(new SimulationTime(1, 0));

	// Create discrete event director as root component			     
        Director director = new TimeTriggeredDomain(null, new SimulationDuration(SimulationDuration._1MS)); 
 
	// - Add director as root component to simulation scenario
        simulationScenario.setRootComponent(director);							     

    	// Create simulation components and input value providers
        ConstantValueProvider<Integer> p1 = new ConstantValueProvider<Integer>(director); p1.setValue(1);   	// this value will turn on the platforms
        ConstantValueProvider<Integer>   p2 = new ConstantValueProvider<Integer>(director); p2.setValue(10000); // this value will set the speed of the platforms to 10000
        
        // - Create value consumers
        TTValueConsumer c1 = new TTValueConsumer(director, "c1");	//This one is for the Laser 
        
        
        String myLibPath = System.getProperty("user.dir")+("/src.c.testsuite/driveBelt.simple");
        System.setProperty("java.library.path", myLibPath);
        System.out.println(myLibPath);
        
        
        
        // C behavior task
        SingleTimedCTask behavior = new TestCDrivebelt (director, System.getProperty("user.dir")+("/src.c.testsuite/driveBelt.simple/libdriveBelt_simple.so"));
        
        // Create links between component ports
        new LinkImpl(p1, "output", behavior, "DriveOn");
        new LinkImpl(p2, "output", behavior, "speed");
        
        new LinkImpl(behavior, "Laser1", c1, "input");   
    }


    /**
     * Run this simulation scenario
     */
    public void runSimulationScenario() {
        // Initialize simulation scenario
        simulationScenario.init();
        
        // Print console message
        simulationScenario.getConsole().debug("Testing nested directors using simplified interface (time->event)");
    
        // Start simulator
        simulationScenario.execute();
    }

    
    /**
     * Main function
     * 
     * @param args Command line arguments
     */
    public static void main(String[] args) {
        // Create and execute test component
        new TestConnectorDrivebelt().runSimulationScenario();
    }
}







