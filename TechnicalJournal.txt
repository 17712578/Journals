08/03/2017
The drivers have a speed range of 20,000 to -20000.
Normally 7 variables are linked to one platform

Problems
	PE034 is not built in to the system
	Header file cannot be found
	Reflective memory is not connected to the embedded server 

---------------------------------------------------------------------------------------------------------
09/03/2017
The driver manaul
-The driver contains API functions that enable you to
	Open and close the driver
	Configure the board
	Transfer data 
	Control/handle interrupts events
- When writing code
	The first step is to open the driver
	You can call RFM2gErrorMsg() function with the error to retrieve a description of the error code
	Byte swapping may be required due to different systems requiring Big Endian & Little Endian 

---------------------------------------------------------------------------------------------------------
10/03/2017
-To convert a decimal from a variable back in ascii
	Decimal => hexdecimal => break into two individual bytes => compare against ascii table
- My first Task is
	To write some code that will load a pallet on to platform 21 and then have the platform move the
	pallet 23 & 24, which centres the pallet over the coilcar lifter.  
	Functions required are RFM2gPoke32, STDRFM2GCALL and a delay loop as we are unable to read the LEDs yet
---------------------------------------------------------------------------------------------------------
13/03/2017
-First task is all most complete, just need to adjust timing as the Leds are not impleted as variables yet



code as at 13/03

		// STDRFM2GCALL result = RFM2gPoke32(handle, Offset+Index*4,Value) Offset = 0x708840;
		{	
		STDRFM2GCALL result = RFM2gPoke32(handle, 7378564,33554432) // Booking_Pallet_ID 
		STDRFM2GCALL result = RFM2gPoke32(handle, 7376450,1345388544) // Poke "P1" into Booking_Pallet_ID_1 
		
		STDRFM2GCALL result = RFM2gPoke32(handle, 7376496,83886080) // Booking_Pallet_Location 
		STDRFM2GCALL result = RFM2gPoke32(handle, 7376500,1346711602) //Poke "PE02" into Booking_Pallet_Location
		STDRFM2GCALL result = RFM2gPoke32(handle, 7376504,822083584) // Poke "1" Booking_Pallet_Location
		
		STDRFM2GCALL result = RFM2gPoke32(handle, 7376516,1) //Set Booking_Pallet_BookIn to "True" by inserting a '1'
		sw_delay_ms(500);										 //Delay
		STDRFM2GCALL result = RFM2gPoke32(handle, 7376516,0) //Set it back to "false"
		sw_delay(500);	
		
		STDRFM2GCALL result = RFM2gPoke32(handle, 7376648,-5000) //Speed
		STDRFM2GCALL result = RFM2gPoke32(handle, 7376780,1) //Drive on

---------------------------------------------------------------------------------------------------------
14/03/2017
The swap function we are trying to update
 int main (void)
{
	char Name[20];
	char NewName[20];
	unsigned int num1 = 0;
	unsigned int num2 = 0;
	unsigned int num3 = 0;
	unsigned int num4 = 0;
	
	//while ((fgets( Name, sizeof(Name), stdin ) == (char *) NULL ) ||(strlen(Name) < 2))
    	sprintf(Name, "PE021");
   	 printf("The length of Name is: %d, NewName: %s\n",strlen(Name),  NewName);
//	int a = 0;
	for (int i = 5-1; i >= 0; i--)	
	{
		NewName[5-i] = Name[i];
	//	a++;
	}
	printf("Name: %s, NewName: %s, the length of it is. %d \n",Name,  NewName, strlen(NewName));
	
	for (int i = (strlen(NewName) - 1); i >= 0; i--)	
	{
	   if (strlen(NewName) - i <= 4)
	    { 
	    	num1 = (num1 << 8) + NewName[i];
    	}
        else if(strlen(NewName)- i <= 8)
    	{ 
	    	num2 = (num2 << 8) + NewName[i];
    	}
    	else if(strlen(NewName)- i <= 12)
    	{ 
	    	num3 = (num3 << 8) + NewName[i];
    	}
    	else if(strlen(NewName)- i <= 16)
    	{ 
	    	num4 = (num4 << 8) + NewName[i];
    	}
    	
	}
    printf("%d,%d,%d,%d\n",num1,num2,num3,num4);
}


---------------------------------------------------------------------------------------------------------
14/03/2017
Finished Swap Function
void Swapstring (void)
{
	char Name[20];
	unsigned int num1 = 0;
	unsigned int num2 = 0;
	unsigned int num3 = 0;
	unsigned int num4 = 0;
    	int i;
	
	while ((fgets( Name, sizeof(Name), stdin ) == (char *) NULL ) ||(strlen(Name) < 2)){} // This is where the code asks for user input
    
	if (Name[strlen(Name) - 1] == '\n') 	// In C89 the arrays always have a new line character at the end of the array, this was causing problems when converting to an int
   	 Name[strlen(Name) - 1] = '\0';		// So these two lines of code removed the '\n' and replace it with null character '\o'
    
    	int a = 0;

	for (i = (strlen(Name) - 1); i >= 0; i--)	// This for loop swaps the character order in the array and groups them into fours 
	{
	   if (strlen(Name) - a >= 13)
	    { 
	    	num4 = (num4 << 8) + Name[i];
	    	a++;
    	    }
       	    else if(strlen(Name)- a >= 9)
    	    { 
	    	num3 = (num3 << 8) + Name[i];
	     	a++;
    	    }
    	    else if(strlen(Name)- a >= 5)
    	    { 
	    	num2 = (num2 << 8) + Name[i];		// "<< 8" is beasuse we need to shift the numbers in hex 
	    	a++;
            }
    	    else if(strlen(Name)- a >= 0)		// Eg. 'P''E''0''2''1' => '1''2''0''E''P'=> 0x31,0x32,0x30,0x45,0x50 => num1 = 0x32,0x30,0x45,0x50. num2 = 0x31
    	    { 
	    	num1 = (num1 << 8) + Name[i];		//i think this for loop is best code i have ever written
	    	a++;
    	    }
	}
    
	if(direction == 1)
	{
		result = RFM2gPoke32(Handle, offset + Booking_Pallet_ID_1*4,num1); 	//  Poke the Name of Pallet into variable Booking_Pallet_ID_1 
		result = RFM2gPoke32(Handle, offset + Booking_Pallet_ID_2*4,num2); 	//  Poke the Name of Pallet into variable Booking_Pallet_ID_2
		result = RFM2gPoke32(Handle, offset + Booking_Pallet_ID_3*4,num3); 	//  Poke the Name of Pallet into variable Booking_Pallet_ID_3 
		result = RFM2gPoke32(Handle, offset + Booking_Pallet_ID_4*4,num4); 	//  Poke the Name of Pallet into variable Booking_Pallet_ID_3
	}
	if(direction == 2)
	{
		result = RFM2gPoke32(Handle, offset + Booking_Pallet_Location_1*4,num1); 	//  Poke the Name of Pallet into variable Booking_Pallet_ID_1 
		result = RFM2gPoke32(Handle, offset + Booking_Pallet_Location_2*4,num2); 	//  Poke the Name of Pallet into variable Booking_Pallet_ID_2
		result = RFM2gPoke32(Handle, offset + Booking_Pallet_Location_3*4,num3); 	//  Poke the Name of Pallet into variable Booking_Pallet_ID_3 
		result = RFM2gPoke32(Handle, offset + Booking_Pallet_Location_4*4,num4); 	//  Poke the Name of Pallet into variable Booking_Pallet_ID_3
	}
}	


---------------------------------------------------------------------------------------------------------
15/03/2017		
	void main()
{
		 result = RFM2gPoke32(Handle, offset + Booking_Pallet_ID*4,Pallet_ID); 			// Constant
		 SetPalletName(); 									// Asks user for name of Pallet, swapString is called from this function 
		 result = RFM2gPoke32(Handle, offset + Booking_Pallet_Location*4,Pallet_Location);	// Constant
		 SetLocationofPallet();									// Asks user for Location of Pallet, swapString is called from this function 
		 result = RFM2gPoke32(Handle, offset + Booking_Pallet_BookIn*4,True); 			//Book in that pallet to the location
		 sleep(1);										//Delay for a second
		 result = RFM2gPoke32(Handle, offset + Booking_Pallet_BookIn*4,False); 			//Then reset the bookin variable so it can be used again another time
		 result = RFM2gPoke32(Handle, offset + DPSIM__ScaledRotSpd_PE021*4,Speed); 		//Set speed of motors to a hardcoded value, will fix this later
		 result = RFM2gPoke32(Handle, offset + DPSIM__DriveOn_PE021*4,1); 			//Turn on the platform
		 result = RFM2gPoke32(Handle, offset + DPSIM__ScaledRotSpd_PE24*4,Speed);		//"			"
		 result = RFM2gPoke32(Handle, offset + DPSIM__DriveOn_PE024*4,1); 			//"			"
		 sleep(68);										//Wait for the pallet to be transfer across the platfroms
		 result = RFM2gPoke32(Handle, offset + DPSIM__DriveOn_PE021*4,0); 			//Turn Platforms off
		 result = RFM2gPoke32(Handle, offset + DPSIM__DriveOn_PE024*4,0); 			//	 
}

---------------------------------------------------------------------------------------------------------
21/03/2017
	void main()
{
		//result = RFM2gPoke32(handle, Offset+Index*4,Value) Offset = 0x708840;	
		 result = RFM2gPoke32(Handle, offset + Booking_Pallet_ID*4,Starting_ID);	 	// Constant
		 result = RFM2gPoke32(Handle, offset + Booking_Coil_ID*4,Starting_ID); 			// Constant
		 SetPalletName(); 									// Calls the Function which receives the name of the pallet from the User
		 
		 result = RFM2gPoke32(Handle, offset + Booking_Pallet_Location*4,Starting_Location);	// Constant
		 result = RFM2gPoke32(Handle, offset + Booking_Coil_Location*4,Starting_Location);	// Constant
		 SetLocationofPallet(); 								// Calls the Function which receives the required location from the user
		 
		 /* Set parameters of the aluminium coil */

		 result = RFM2gPoke32(Handle, offset + Booking_Coil_OuterDiameter*4,OuterDiameter);		
		 result = RFM2gPoke32(Handle, offset + Booking_Coil_InnerDiameter*4,InnerDiameter);
		 result = RFM2gPoke32(Handle, offset + Booking_Coil_Width*4,Width);
		 result = RFM2gPoke32(Handle, offset + Booking_Coil_Thickness*4,Thickness);
		 result = RFM2gPoke32(Handle, offset + Booking_Coil_Temperature*4,Temperature);
		 
		 /* Books in the Pallet and Coil, also reset the variables back to off so it is possible to use again*/

		 result = RFM2gPoke32(Handle, offset + Booking_Pallet_BookIn*4,On); 	
		 result = RFM2gPoke32(Handle, offset + Booking_Pallet_BookIn*4,Off); 		
		 sleep(1);										//Give the pallet time to appear on screen
		 result = RFM2gPoke32(Handle, offset + Booking_Coil_BookIn*4,On); 	
		 result = RFM2gPoke32(Handle, offset + Booking_Coil_BookIn*4,Off); 		
		
		 /* Turn on and adjust speed of platforms*/

		 result = RFM2gPoke32(Handle, offset + ScaledRotSpd_PE021*4,Speed); 
		 result = RFM2gPoke32(Handle, offset + DriveOn_PE021*4,1); 
		 result = RFM2gPoke32(Handle, offset + ScaledRotSpd_PE024*4,Speed); 
		 result = RFM2gPoke32(Handle, offset + DriveOn_PE024*4,1); 
		 sleep(67); 										//Wait for pallet to arrive at position
		 result = RFM2gPoke32(Handle, offset + DriveOn_PE021*4,0); 				//Turn off platforms
		 result = RFM2gPoke32(Handle, offset + DriveOn_PE024*4,0); 
		 
		 /* Turn on and adjust speed of the Coil Car*/

		 result = RFM2gPoke32(Handle, offset + Tr1OpenBreak_CC*4,On); 				//Start
		result = RFM2gPoke32(Handle, offset + Tr1ScaledRotSpd_CC*4,PositiveSpeed); 
		sleep(23);										//Wait for Coilcar to arrive at position												
		result = RFM2gPoke32(Handle, offset + Tr1ScaledRotSpd_CC*4,Off); 			//Stop
		result = RFM2gPoke32(Handle, offset + Tr1CoilLifterSvoVlv*4,4234310);			//Raise lifter
		sleep(5);										//Wait for lifter to reach desired height
        
		 /* Read the actual position of the Coil Car, convert this real data to
			an integer and compare to the end position */

		 result = RFM2gPeek32(Handle, offset + CcarTR1_ActPos*4,&BitpatternPos);
		 SwapBitPattern = htole32(BitpatternPos);
		 memcpy(&ActPos, &SwapBitPattern, sizeof(RFM2G_UINT32));
		 while (ActPos <= End_Position)
		 {
			 result = RFM2gPoke32(Handle, offset + Tr1ScaledRotSpd_CC*4,PositiveSpeed);	// Stays trapped within this while loop until the Car reaches its desination 
			 result = RFM2gPeek32(Handle, offset + CcarTR1_ActPos*4,&BitpatternPos);
			 SwapBitPattern = htole32(BitpatternPos);
			 memcpy(&ActPos, &SwapBitPattern, sizeof(RFM2G_UINT32));
		 }
		 result = RFM2gPoke32(Handle, offset + Tr1ScaledRotSpd_CC*4,False);			//Turn off Coilcar
}

---------------------------------------------------------------------------------------------------------
31/03/2017
The Layout of the directory inside the Eclipse workspace, only important files shown. 

part.component.connentor.c
     >>	testsuite
     	     >>	drivebelt			(Java package, run as java application to start program)
		     >>	TestCDrivebelt		(Simple java file that creates input & output ports)
			TestConnectorDrivebelt	(A more complex java file shown below)
     >>	src.c.testsuite
	     >>	driveBeltsimple.simple
		     >>	Local.h 	(Header file that contains all the factory variables)
			main.c 		(Main C file)
			main.o		(Executeable file for main.c)
			makefile 	(Makefile which links the directory of all other header files)
			libdriveBeltsimple.sc



/* TestConnectorDrivebelt */

package drivebelt;

import part.connector.c.task.SingleTimedCTask;
import director.timedirector.simpleapi.TimeTriggeredDomain;
import scenario.consolescenario.ConsoleScenario;
import simulator.core.framework.api.ScenarioIF;
import simulator.core.framework.components.link.LinkImpl;
import simulator.core.framework.director.coredirector.Director;
import simulator.core.framework.time.SimulationDuration;
import simulator.core.framework.time.SimulationTime;
import sumController.helper.ConstantValueProvider;
import testsuite.connector.c.timed.simpletask.behavior.TTValueConsumer;

/**
 * Test class for the simulator
 * 
 * This test scenario consists of a time triggered director that has a nested event
 * triggered director
 * 
 * @author Dr. Thomas Kuhn
 *
 */

public class TestConnectorDrivebelt 
{

    /**
     * Store simulation scenario
     */
    
    protected ScenarioIF simulationScenario;
    
    
    /**
     * Constructor
     * Sets up simulation scenario
     */

    public TestConnectorDrivebelt() 
    {
	// Create scenario with defined ending time
        simulationScenario = new ConsoleScenario(new SimulationTime(1, 0));

	// Create discrete event director as root component			     
        Director director = new TimeTriggeredDomain(null, new SimulationDuration(SimulationDuration._1MS)); 
 
	// - Add director as root component to simulation scenario
        simulationScenario.setRootComponent(director);							     

    	// Create simulation components and input value providers
        ConstantValueProvider<Integer> p1 = new ConstantValueProvider<Integer>(director); p1.setValue(1);   	// this value will turn on the platforms
        ConstantValueProvider<Integer>   p2 = new ConstantValueProvider<Integer>(director); p2.setValue(10000); // this value will set the speed of the platforms to 10000
        
        // - Create value consumers
        TTValueConsumer c1 = new TTValueConsumer(director, "c1");	//This one is for the Laser 
        
        
        String myLibPath = System.getProperty("user.dir")+("/src.c.testsuite/driveBelt.simple");
        System.setProperty("java.library.path", myLibPath);
        System.out.println(myLibPath);
        
        
        
        // C behavior task
        SingleTimedCTask behavior = new TestCDrivebelt (director, System.getProperty("user.dir")+("/src.c.testsuite/driveBelt.simple/libdriveBelt_simple.so"));
        
        // Create links between component ports
        new LinkImpl(p1, "output", behavior, "DriveOn");
        new LinkImpl(p2, "output", behavior, "speed");
        
        new LinkImpl(behavior, "Laser1", c1, "input");   
    }

    /**
     * Run this simulation scenario
     */
    public void runSimulationScenario() {
        // Initialize simulation scenario
        simulationScenario.init();
        
        // Print console message
        simulationScenario.getConsole().debug("Testing nested directors using simplified interface (time->event)");
    
        // Start simulator
        simulationScenario.execute();
    }
  
    /**
     * Main function
     * 
     * @param args Command line arguments
     */
    public static void main(String[] args) {
        // Create and execute test component
        new TestConnectorDrivebelt().runSimulationScenario();
    }
}
---------------------------------------------------------------------------------------------------------
07/04/2017

Old header file

#define DriveOn_PE001			//Each platform has two varaibles each
#define ScaledRotSpd_PE001
#define DriveOn_PE002
#define ScaledRotSpd_PE002
........
#define CcarTR1_ActPos 343		//6 variables per coil car
#define XSTr1CoilLifterActPos 344
#define XSTr1CoilLifterCoilWeightFr 345
#define Tr1CoilLifterSvoVlv 403			
#define Tr1ScaledRotSpd_CC 404			
#define Tr1OpenBreak_CC 407  			
........
					//No laser variables



New header file

#define Read_DriveOn_PE001 639		//Each platform has four varaibles each 
#define Read_Speed_PE001 640
#define Write_DriveOn_PE001 641 
#define Write_Speed_PE001 642
........
#define  CoilCar1_PalDetected 605	//9 variables per coil car
#define  CoilCar1_LiftHighPrOn 606
#define  CoilCar1_TravRefPos 607
#define  CoilCar1_LiftVlvLowPrOn 608
#define  CoilCar1_LiftChkVlvDn 609
#define  CoilCar1_LiftChkVlvUp 610
#define  CoilCar1_LiftVlvUpDown 611
#define  CoilCar1_TravActCnt 612
#define  CoilCar1_LiftActCnt 613
........
#define PE001_BLST1_FwdSlow 430		// 5 laser variables per platform
#define PE001_BLST2_FwdStop 431
#define PE001_BLST3_BwdStop 432
#define PE001_BLST4_BwdSlow 433
#define PE001_BLSR1_CoilDetected 434

Also includes variables for 9 new factory components
----------------------------------------------------------------------------------------------------------
18/04/2017
Template for my different states 

      while(statemachine == 1) 
    {    
	// Code which turns on platforms 

	// Code which reads the lasers

         if((htobe32(Laser1) & htobe32(Laser2))== 1)
            {
        	 // code the turns off platforms
        	 printf("End of stage 1\n ");
        	 statemachine = 2;			//Next State
            }

	printf("Stage 1\n"); 				// Printf used for debugging and so i can montior which stage the code is at.
    }  

 Repeat 36 times.....

---------------------------------------------------------------------------------------------------------- 
24/04/2017
ShiftTableController: {
	// Create high level behavior using high level signals and commands only 
	Instantiable ShiftTableController = fsm.type() {
	
		initial("waitForCoil") {
			entry {
				println "Waiting for command";
			}
			
			// Receive a message that indicates that all four sensors are reporting a coil
			to("shiftTablePart1") on Plant_CoilDetected;
		}
		
		state("shiftTablePart1") {
			entry {
				println "The shift table is now moving";
				fsm.tx("Speed_PU010", new IntegerMessage(20000));
				fsm.tx("DriveOn_PU010", new IntegerMessage(1));
			}
			to("shiftTablePart2") on Message when {PU010_SBE2__TravBwdSlow == 1}
		}
		
		state("shiftTablePart2") {
			entry {
				println "The shift table is slowing down";
				fsm.tx("Speed_PU010", new IntegerMessage(5000));
			}
			to("shiftTablePart3") on Message when {PU010_SBE1__TravBwdStop == 1}
		}
		
		state("shiftTablePart3") {
			entry {
				println "The shift table is stopping";
				fsm.tx("DriveOn_PU010", new IntegerMessage(0));
			}
			to("Platform19") after ({ new SimulationDuration(1.s)});
		}
	}
	
	putOnMandrelController.runtimeEnvironment.changeBehavior(ShiftTableController);
}

---------------------------------------------------------------------------------------------------------- 
25/04/2017

putOnMandrelController: {
	// Create high level behavior using high level signals and commands only 
	Instantiable mandrelControllerBehavior = fsm.type() {


	initial("waitForCoil") {
		entry {
			println "Waiting for command";
		}
		// Receive a message that indicates that all four sensors are reporting a coil
		to("coilCarPart1") on Plant_CoilDetected;
	}

	state("coilCarPart1") {
		entry {
			println "Coil car is now moving to underneath the pallet";
				
			fsm.tx("Speed_K13BE", new IntegerMessage(20000));
			fsm.tx("DriveOn_K13BE", new IntegerMessage(1));
		}
		to("coilCarPart2") on Message when //{CoilCar1_TravActCnt > UNDER_THE_PALLET}	
	}

	state("coilCarPart2") {
		entry {
			//From here on, At the start of every state the variables from the previous state are turned off //
			fsm.tx("DriveOn_K13BE", new IntegerMessage(0));	
			

			println "Coil car is stationary, Lifter is lifting pallet!";
			fsm.tx("CoilCar1_LiftChkVlvUp", new IntegerMessage(1));
			fsm.tx("CoilCar1_LiftVlvUpDown", new IntegerMessage(writeRealNbr(17000)));
			fsm.tx("CoilCar1_LiftVlvLowPrOn", new IntegerMessage(1));
		}
		to("coilCarPart3") on Message when //{CoilCar1_LiftActCnt > MAXIMUM_SAFTEY_HEIGHT}
	}
	
	state("coilCarPart3") {
		entry {
			fsm.tx("CoilCar1_LiftChkVlvUp", new IntegerMessage(0));

			fsm.tx("CoilCar1_LiftVlvUpDown", new IntegerMessage(0));

			fsm.tx("CoilCar1_LiftVlvLowPrOn", new IntegerMessage(0));

	
			println "Coil car is now carrying pallet torwards the mandrel";
				
			fsm.tx("DriveOn_K13BE", new IntegerMessage(1));
		}
		to("coilCarPart4") on Message when //{CoilCar1_TravActCnt > RIGHT_BEFORE_THE_MANDREL }
	}

	state("coilCarPart4") {
		entry {
			fsm.tx("DriveOn_K13BE", new IntegerMessage(0));


			println "Lifter is now moving pallet inline with Mandrel!";

			fsm.tx("CoilCar1_LiftChkVlvUp", new IntegerMessage(1));
	
			fsm.tx("CoilCar1_LiftVlvUpDown", new IntegerMessage(writeRealNbr(17000)));//4234310
				
			fsm.tx("CoilCar1_LiftVlvLowPrOn", new IntegerMessage(1)); 
		}
		to("coilCarPart5") on Message when //{CoilCar1_LiftActCnt > INLINE_WITH_MANDREL}
	}

	state("coilCarPart5") {
		entry {
			fsm.tx("CoilCar1_LiftChkVlvUp", new IntegerMessage(0));

			fsm.tx("CoilCar1_LiftVlvUpDown", new IntegerMessage(0));

			fsm.tx("CoilCar1_LiftVlvLowPrOn", new IntegerMessage(0));


			println "Coil car is now moving coil onto Mandrel!";

			fsm.tx("DriveOn_K13BE", new IntegerMessage(1));
		}
		to("coilCarPart6") on Message when //{CoilCar1_TravActCnt > ONTO_THE_MANDREL }
	}

	state("coilCarPart6") {

		entry {
			fsm.tx("DriveOn_K13BE", new IntegerMessage(0));


			println "Lifter is lowering away from the Mandrel!";

			fsm.tx("CoilCar1_LiftChkVlvDn", new IntegerMessage(1));

		}

		to("coilCarPart7") on Message when //{CoilCar1_LiftActCnt > MINIMUM_SAFTEY_HEIGHT}

	}

	state("coilCarPart7") {
			
		entry {
				
			fsm.tx("CoilCar1_LiftChkVlvDn", new IntegerMessage(0));


			println "Coil car is returning pallet to original position!";

			fsm.tx("DriveOn_K13BE", new IntegerMessage(1));

			fsm.tx("Speed_K13BE", new IntegerMessage(-20000));

		}

		to("Platform22") on Message when //{CoilCar1_TravActCnt > BACK_TO_PLATFORM }

	}
	}

	putOnMandrelController.runtimeEnvironment.changeBehavior(mandrelControllerBehavior);
}
---------------------------------------------------------------------------------------------------------- 
26/04/2017

// Low-Level Behavior

beltController2: {

	// Create low behavior using level signals and low level commands

	Instantiable beltControlbehavior2 = fsm.type() {

def speed=20000;

		initial("waitForCommand") {

			// Receive a message that indicates that all four sensors are reporting a coil

			println "beltController waiting for command";

			to ("startMoving") on ERP_RequestPutonMandrel

			// SMSVariableUpdateNotification when {FSMContainer fsm, SMSVariableUpdateNotification msg -> msg.getValue() == 1 && msg.src=="PE005_BLST1_FwdSlow"};

			//to("startMoving") on SENSOR_ChangeMsg when {FSMContainer fsm, Message<?> msg -> msg.getValue() == Sensor_PE005_BLST3};

		}



		state("startMoving") {

			entry{

				FSMContainer fsm, msg->

					println "start moving belts in FERAL"

					fsm.tx("DriveOn_PE033", new IntegerMessage(1));

					fsm.tx("Speed_PE033", new IntegerMessage(-speed));


					
fsm.tx("DriveOn_PE19", new IntegerMessage(1));

					fsm.tx("Speed_PE019", new IntegerMessage(speed));


					
fsm.tx("DriveOn_PE021", new IntegerMessage(1));

					fsm.tx("Speed_PE021", new IntegerMessage(speed));


					
fsm.tx("DriveOn_PE023a", new IntegerMessage(1));

					fsm.tx("Speed_PE023a", new IntegerMessage(speed));

		
			
					fsm.tx("DriveOn_PE023b", new IntegerMessage(1));

					fsm.tx("Speed_PE023b", new IntegerMessage(speed));

			}

			to ("reduceSpeed") on SMSVariableUpdateNotification when {FSMContainer fsm, SMSVariableUpdateNotification msg -> msg.getValue() == 1 && msg.src=="PE023_BLST1_FwdSlow"};

		}


		
state("reduceSpeed"){

			entry{

				FSMContainer fsm, msg->

				fsm.tx("Speed_PE023", new IntegerMessage(5000));

			}
			
			to("stopMoving") on SMSVariableUpdateNotification when {FSMContainer fsm, SMSVariableUpdateNotification msg -> msg.getValue() == 1 && msg.src=="PE023_BLST2_FwdStop"};

		}


		
state("stopMoving"){

			entry{

				FSMContainer fsm, msg->

					println "stop moving belts in FERAL"

					
fsm.tx("DriveOn_PE033", new IntegerMessage(0));

					fsm.tx("Speed_PE033", new IntegerMessage(0));


					
fsm.tx("DriveOn_PE019", new IntegerMessage(0));

					fsm.tx("Speed_PE019", new IntegerMessage(0));


					
fsm.tx("DriveOn_PE021", new IntegerMessage(0));

					fsm.tx("Speed_PE021", new IntegerMessage(0));


					
fsm.tx("DriveOn_PE023a", new IntegerMessage(0));

					fsm.tx("Speed_PE023a", new IntegerMessage(0));


					fsm.tx("DriveOn_PE023b", new IntegerMessage(0));

					fsm.tx("Speed_PE023b", new IntegerMessage(0));


					
fsm.tx("callNextService", new IntegerMessage(1));

				
}

		}

	}

	DigRep_ControlBelt.changeBehavior(beltControlbehavior2);

}

---------------------------------------------------------------------------------------------------------- 
27/04/2017

#define STOP_POINT 10463600
#define MAXIMUM_ERROR 10464350
#define MINIMUM_ERROR 10462850

while(statemachine == 46)
{
	//Read the variable the shows the position of the turn table 
	result = RFM2gPeek32(Handle, offset + PL003_BWL1__TurnActCnt*4,&cnt);	
	//htobe32() is a function that converts the 32 bit integer little endian format into and   
	cnt2= htobe32(cnt);
	while(cnt <= MINIMUM_ERROR && >= MAXIMUM_ERROR)
	{
		  result = RFM2gPeek32(Handle, offset + PL003_BWL1__TurnActCnt*4,&cnt);
		  cnt2= htobe32(cnt);
		  variablespeed = ((STOP_POINT - cnt2)/200)
		  if(variablespeed > 20000)
			{
				variablespeed = 20000;
			}
		  printf("speed2 is: %d \n", variablespeed);
		 result = RFM2gPoke32(Handle, offset + Write_Speed_PL003*4, htobe32(variablespeed));
		 result = RFM2gPoke32(Handle, offset + Write_DriveOn_PL003*4,htobe32(drive_on));
	}
	result = RFM2gPoke32(Handle, offset + Write_DriveOn_PL003*4,htobe32(Off));
	printf("Finished\n");
}
---------------------------------------------------------------------------------------------------------- 

public accelerationControllerBehavior(TimeTriggeredSimulationComponent simComponent) {
	// Invoke constructor of base component
	super(simComponent);

	// Create input port
	createInputPort("Read_PE005");
	createInputPort("callService");
	// Create output port
	createOutputPort("Speed_PE005");
	createOutputPort("DriveOn_PE005");
	createOutputPort("ServiceFinished");
}
	

	/**
	 * Produce message
	 */
	@Override
	public void timeStep() {
		
		
		System.out.println("Calculating speed for platform");
		
		Message<? extends Object> StartMessage =  this.getInputMessage("callService");
		if(StartMessage instanceof StartServiceMessage){
		
			int currentPlatformSpeed = this.getInputVariable("Read_PE005");
			
			if(currentPlatformSpeed > 20000)
			{
				 this.setOutputVariable("ServiceFinished","PlatformAtMaxspeed");
				System.out.println("Platform has accelerated to its topspeed");
			}
			else
			{
				currentPlatformSpeed += 2000;
			}

			// - Set output value
			this.setOutputVariable("Speed_PE005", currentPlatformSpeed );
			this.setOutputVariable("DriveOn_P005", 1);
		}
	}
}
---------------------------------------------------------------------------------------------------------- 
19/07/2017
public class PE010BeltControllerBehavior {
	// Create low behavior using level signals and low level commands
	public static Instantiable beltControlbehavior = fsm.type() {
			int speed=20000;
		initial("waitForCommand") {
			// Receive a message that indicates that all four sensors are reporting a coil
			println "beltController waiting for command";
			to ("waiting") on StartServiceMessage
		}
		state("waiting"){
			to("startMoving") after {new SimulationDuration(1.s)};
		}
		state("startMoving") {
			entry{
				FSMContainer fsm, msg->
					println "start moving platform PE010"
					fsm.tx("DriveOn_PE009", new IntegerMessage(1));
					fsm.tx("Speed_PE009", new IntegerMessage(speed));
					fsm.tx("DriveOn_PE010", new IntegerMessage(1));
					fsm.tx("Speed_PE010", new IntegerMessage(speed));
					fsm.tx("DriveOn_PE011", new IntegerMessage(1));
					fsm.tx("Speed_PE011", new IntegerMessage(speed));
			}
			to ("movingRightStopLeftSide") on UpdateNotificationMessage when {FSMContainer fsm, UpdateNotificationMessage msg -> msg.getValue() == 1 && msg.src=="PE011_BLST2_FwdStop"};
			to ("movingLeftStopRightSide") on UpdateNotificationMessage when {FSMContainer fsm, UpdateNotificationMessage msg -> msg.getValue() == 1 && msg.src=="PE009_BLST3_BwdStop"};
		}
		state("movingRightStopLeftSide"){
			entry{
				FSMContainer fsm, msg->
					println "stop moving platform PE010"
					fsm.tx("DriveOn_PE009", new IntegerMessage(0));
					fsm.tx("Speed_PE009", new IntegerMessage(0));
					fsm.tx("DriveOn_PE010", new IntegerMessage(0));
					fsm.tx("Speed_PE010", new IntegerMessage(0));
					
					fsm.tx("ServiceFinished", new ServiceFinishedMessage("beltControlPE010Finished"));
			}
			to ("waitForCommand");
		}
		state("movingLeftStopRightSide"){
			entry{
				FSMContainer fsm, msg->
					println "stop moving platform PE010"
					fsm.tx("DriveOn_PE010", new IntegerMessage(0));
					fsm.tx("Speed_PE010", new IntegerMessage(0));
					fsm.tx("DriveOn_PE011", new IntegerMessage(0));
					fsm.tx("Speed_PE011", new IntegerMessage(0));
						
					fsm.tx("ServiceFinished", new ServiceFinishedMessage("beltControlPE010Finished"));
			}
			to ("waitForCommand");
		}
	}
}

---------------------------------------------------------------------------------------------------------- 
19/07/2017
/**
 * Product controller
 * 
 * @author kelly
 *
 */
public class ProductController1Behavior{
	public Instantiable productController1Behavior;
	public ProductController1Behavior(String previousWaypoint){
		productController1Behavior = fsm.type() {
		String BehaviorMessage;
	
		initial("waitForCommand") {
			//Start Product Controller once pallet and Coil have been booked in
			to ("acquiringWaypoint") on ServiceFinishedMessage when {FSMContainer fsm, Message msg -> msg.getValue() == "CoilAtShopFloor"};	 
		}
			
		state("acquiringWaypoint") {
			entry {
				FSMContainer fsm, msg ->
					//Send previousWaypoint to Linecontroller and receive back a new waypoint to send as a behavior message to the beltControllers
				
					//System.out.println("Previous Message:" + previousWaypoint);	//Debug message
					BehaviorMessage = LineControllerBehavior.getNextPlatformWaypoint(previousWaypoint);
					previousWaypoint = BehaviorMessage;
					//System.out.println("Behavior Message:" + BehaviorMessage);  //Debug message
			   }					 
			to ("StartBehavior");
		   }
		   
		state("StartBehavior") {
			entry{
				FSMContainer fsm, msg ->
					//Sends Behavior Message and return to above state once beltController has finished
					 fsm.tx(BehaviorMessage, new StartServiceMessage());
			   }
			to ("acquiringWaypoint") on ServiceFinishedMessage when {FSMContainer fsm, Message msg -> msg.getValue() == (BehaviorMessage+"Finished")};
		   }
		}
	}
}

------------------------------------------------------------------------------------------------------------------------------------
/**
 * Pallet Position Calculator
 * @author Kelly
*/
public class PositionCalculator extends EventTriggeredWorker {
	//These variables need to be sent into the system from Bookin, Hardcoded for now
	protected String outputString;
	protected int currentPosition 				=   12;
	protected String currentPlatformSpeedName = "PE033_speed";
	protected String currentLightBarrier1Name = "PE033_BLST1_FwdSlow";
	protected String currentLightBarrier2Name = "PE033_BLST2_FwdStop";
	protected String currentLightBarrier3Name = "PE033_BLST3_BwdStop";
	protected String currentLightBarrier4Name = "PE033_BLST4_BwdSlow";
	//The variables for the next platform do not pre-defined, they are calculated based on the speed & direction
	protected int nextPosition 					=   0;
	protected int currentPlatformSpeedStatus	= 	0;
	protected String nextLightBarrier1Name;
	protected String nextLightBarrier2Name;
	protected String nextLightBarrier3Name;
	protected String nextLightBarrier4Name;
	//These are defined to unknown state at the start (2), LightBarrier on (1), LightBarrier off (0),
	protected int currentLightBarrier1Status = 2; 
	protected int currentLightBarrier2Status = 2;
	protected int currentLightBarrier3Status = 2;
	protected int currentLightBarrier4Status = 2;
	protected int nextLightBarrier1Status = 0;
	protected int nextLightBarrier2Status = 0;
	protected int nextLightBarrier3Status = 0;
	protected int nextLightBarrier4Status = 0;
	//Order of the platforms in the factory 
	protected String[] factoryMapArray = ["05","08","09","10","11","06","03","12","15","14","13","16","33","19","21","23","22","26","20","29","27","28","30","25","31","34"];
	
	
	public PositionCalculator(EventTriggeredSimulationComponent simComponent) {
		// Invoke base constructor
		super(simComponent);

		// One input for the speed of the current platform
		InputPort input1 = new InputPortImpl(this.getSimulationComponent());
		input1.setName("currentSpeedPort");
		this.getSimulationComponent().addComponent(input1);
		
		// Four inputs for the lightBarriers of the current platform 
		InputPort input2 = new InputPortImpl(this.getSimulationComponent()); // Create input port
		input2.setName("currentLaser1");// - Set port name
		this.getSimulationComponent().addComponent(input1);// - Add input port to component
		InputPort input3 = new InputPortImpl(this.getSimulationComponent());
		input3.setName("currentLaser2");
		this.getSimulationComponent().addComponent(input3);
		InputPort input4 = new InputPortImpl(this.getSimulationComponent());
		input4.setName("currentLaser3");
		this.getSimulationComponent().addComponent(input4);
		InputPort input5 = new InputPortImpl(this.getSimulationComponent());
		input5.setName("currentLaser4");
		this.getSimulationComponent().addComponent(input5);
		
		// Four inputs for the lightBarriers of the next platform 
		InputPort input6 = new InputPortImpl(this.getSimulationComponent());
		input6.setName("nextLaser1");
		this.getSimulationComponent().addComponent(input6);
		InputPort input7 = new InputPortImpl(this.getSimulationComponent());
		input7.setName("nextLaser2");
		this.getSimulationComponent().addComponent(input7);
		InputPort input8 = new InputPortImpl(this.getSimulationComponent());
		input8.setName("nextLaser3");
		this.getSimulationComponent().addComponent(input8);
		InputPort input9 = new InputPortImpl(this.getSimulationComponent());
		input9.setName("nextLaser4");
		this.getSimulationComponent().addComponent(input9);
		
		// One variable for the Switch status of the current platform
		InputPort input10 = new InputPortImpl(this.getSimulationComponent());
		input10.setName("input10");
		this.getSimulationComponent().addComponent(input10);
	
		
		// Create output port
		OutputPort output = new OutputPortImpl(this.getSimulationComponent());
		// - Set port name
		output.setName("output");
		// - Add output port to component
		this.getSimulationComponent().addComponent(output);
	}
	
	
	/**
	 * First component execution
	 * 
	 * This function may be used to set up initial timers
	 */
	@Override
	public void initialize() {
		//Receive Bookin position
		// - Get current time
		SimulationTime currentTime = this.getSimulationComponent().getSimulationTime();
		// - Timer interval: 0.5 second							    
		SimulationDuration timerInterval = new SimulationDuration(0, 500000000);
		// - Trigger a timer for given interval
		this.getSimulationComponent().scheduleTimer(currentTime.add(timerInterval), null);
	}
	
	/**
	 * An event has been received
	 */
	@Override
	public void messageReceived(Message<? extends Object> rxMsg) {
		// Get value of lightBarrier
		if (rxMsg != null ) {
			if(rxMsg instanceof LightBarrierMessage) {
				//System.out.println("Current Source :" +rxMsg.src);
				//System.out.println("nextLightBarrier1Name are :" +nextLightBarrier1Name);
				switch (rxMsg.src) {
					case currentPlatformSpeedName:	
					currentPlatformSpeedStatus = rxMsg.getValue();
					break;
					case currentLightBarrier1Name:
					currentLightBarrier1Status = rxMsg.getValue();
					break;
					case currentLightBarrier2Name:
					currentLightBarrier2Status = rxMsg.getValue();
					break;
					case currentLightBarrier3Name:
					currentLightBarrier3Status = rxMsg.getValue();
					break;
					case currentLightBarrier4Name:
					currentLightBarrier4Status = rxMsg.getValue();
					break;
					case nextLightBarrier1Name:
					nextLightBarrier1Status = rxMsg.getValue();
					break;
					case nextLightBarrier2Name:
					nextLightBarrier2Status = rxMsg.getValue();
					break;
					case nextLightBarrier3Name:
					nextLightBarrier3Status = rxMsg.getValue();
					break;
					case nextLightBarrier4Name:
					nextLightBarrier4Status = rxMsg.getValue();
					break;
				}
			}
		}		
	}
	
	private void updateScanArea () {
		//There is a public map of the factory which includes the order of the platforms  
		currentLightBarrier1Name = "PE0" + factoryMapArray[currentPosition] + "_BLST1_FwdSlow";
		currentLightBarrier2Name = "PE0" + factoryMapArray[currentPosition] + "_BLST2_FwdStop";
		currentLightBarrier3Name = "PE0" + factoryMapArray[currentPosition] + "_BLST3_BwdStop";
		currentLightBarrier4Name = "PE0" + factoryMapArray[currentPosition] + "_BLST4_BwdSlow";
		
		nextLightBarrier1Name = "PE0" + factoryMapArray[nextPosition] + "_BLST1_FwdSlow";
		nextLightBarrier2Name = "PE0" + factoryMapArray[nextPosition] + "_BLST2_FwdStop";
		nextLightBarrier3Name = "PE0" + factoryMapArray[nextPosition] + "_BLST3_BwdStop";
		nextLightBarrier4Name = "PE0" + factoryMapArray[nextPosition] + "_BLST4_BwdSlow";
		
		currentPlatformSpeedName = "PE0" + factoryMapArray[currentPosition] + "_speed";
	}
	
		
		
	public void directionTest () {
		if(currentPlatformSpeedStatus > 1) {
			//Assign nextPlatform to the right of currentPlatform
			nextPosition = currentPosition + 1;
			this.updateScanArea();
			this.logicForAntiClockwise();
		}
		else if(currentPlatformSpeedStatus < -1 ) {
			//Assign nextPlatform to the left of currentPlatform
			nextPosition = currentPosition - 1;
			this.updateScanArea();
			this.logicForClockwise();
		}
	}
			
	public void logicForAntiClockwise() {
		if(currentLightBarrier1Status == 1) {
			if (nextLightBarrier1Status == 0 && nextLightBarrier2Status == 0 && nextLightBarrier3Status == 0 					&& nextLightBarrier4Status == 0) {
					if (currentLightBarrier4Status == 1) {
						println "Pallet is completely on platform " + factoryMapArray[currentPosition];
					}
					else if (currentLightBarrier2Status == 1)  {
						//println "Pallet is starting to arriving at "+ factoryMapArray[currentPosition];
					}
			}
		else {
			println "Something has been detected on the next Platform , Platform number:"+ factoryMapArray[nextPosition];
		}
		}
		else if(currentLightBarrier1Status == 0) {
			if ((currentLightBarrier2Status == 1) && (currentLightBarrier4Status == 1)) {
				//println "Moving between " + factoryMapArray[currentPosition] "and" + factoryMapArray[nextPosition] ;
			}
			else if ((currentLightBarrier3Status == 1) && (currentLightBarrier4Status == 1)) {
				//println "Pallet is moving off platform " + factoryMapArray[currentPosition];
			}
			else if ((currentLightBarrier4Status == 1) && (nextLightBarrier2Status == 1)) {
				//println "Pallet is almost off platform " + factoryMapArray[currentPosition];
			}
			else if ((nextLightBarrier1Status == 1) && (nextLightBarrier2Status == 1)) {
				//println "Pallet is off platform "+ factoryMapArray[currentPosition];
				//println "changing current platform";
				currentPosition = currentPosition + 1;
				nextPosition = currentPosition + 1;
				currentLightBarrier1Status = 1; currentLightBarrier2Status = 1; currentLightBarrier3Status = 0; 				currentLightBarrier4Status = 0;
				nextLightBarrier1Status = 0;  nextLightBarrier2Status = 0;  nextLightBarrier3Status = 0;  					nextLightBarrier4Status = 0;
				this.updateScanArea();
			}
		}
	}
		
	
	
		
	

	/**
	 * Timer has been expired
	 */
	@Override
	public void timerExpired(TimedEvent timerEvent) {
		// Call logic method
		this.directionTest();
		// - Get current time
		SimulationTime currentTime = this.getSimulationComponent().getSimulationTime();
		// - Timer interval: 0.5 seconds						   
		SimulationDuration timerInterval = new SimulationDuration(0, 500000000);
		// - Trigger a timer for given interval
		this.getSimulationComponent().scheduleTimer(currentTime.add(timerInterval), null);
		
		//this.getSimulationComponent().getOutputPort("output").queueMessage(new IntegerMessage(speed));
		this.getSimulationComponent().getOutputPort("output").queueMessage(new 								LightBarrierMessage("outputString",outputString));
	}
